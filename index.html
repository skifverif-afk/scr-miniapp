<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SCR INFO</title>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }
    .wrap {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      padding: 18px 18px 16px;
      gap: 12px;
    }
    .title {
      font-size: 14px;
      opacity: 0.95;
      letter-spacing: 0.08em;
    }
    .rule {
      opacity: 0.25;
      margin: 6px 0 2px;
      user-select: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: clip;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .small { font-size: 12px; opacity: 0.8; line-height: 1.45; }
    .mono { white-space: pre-wrap; word-break: break-word; font-size: 12px; opacity: 0.92; line-height: 1.55; }

    select, button {
      font-family: inherit;
      font-size: 12px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.25);
      background: #000;
      color: #fff;
      padding: 9px 10px;
    }

    .center {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px 0;
    }

    .btnWrap { text-align: center; }
    .toggle {
      width: 170px;
      height: 170px;
      border-radius: 999px;
      background: #fff;
      color: #000;
      border: 3px solid #111;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      letter-spacing: 0.14em;
      user-select: none;
      cursor: pointer;
    }
    .toggle:active { transform: scale(0.985); }
    .status {
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.92;
      letter-spacing: 0.06em;
    }

    .panel {
      border: 1px solid rgba(255,255,255,0.16);
      border-radius: 14px;
      padding: 12px;
      background: rgba(255,255,255,0.03);
    }
    .panel h3 {
      margin: 0 0 8px;
      font-size: 12px;
      opacity: 0.95;
      letter-spacing: 0.10em;
      font-weight: 800;
    }
    .btnRow { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 10px; }
    .btnGhost {
      background: transparent;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.25);
    }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.22);
      font-size: 11px;
      opacity: 0.9;
      letter-spacing: 0.06em;
    }

    .footerNote {
      font-size: 11px;
      opacity: 0.65;
      line-height: 1.4;
    }

    .hidden { display: none; }
  </style>
</head>

<body>
  <div class="wrap">

    <div>
      <div class="row">
        <div class="title">SCR INFO</div>
        <div class="row" style="gap:10px;">
          <span class="pill" id="pillEnv">ENV: ?</span>
          <span class="pill" id="pillNet">NET: LOCKED</span>
          <label class="small" id="lblLang">LANG</label>
          <select id="lang">
            <option value="ru">RU</option>
            <option value="en">EN</option>
            <option value="zh">中文</option>
          </select>
        </div>
      </div>
      <div class="rule">────────────────────────────────────────────────────────────</div>
      <div class="mono" id="deviceBox"></div>
    </div>

    <div class="center">
      <div class="btnWrap">
        <div class="toggle" id="toggleBtn">OFF</div>
        <div class="status" id="statusText">READY</div>
      </div>
    </div>

    <div class="panel hidden" id="reportPanel">
      <h3 id="hdrReport">SCR REPORT</h3>
      <div class="mono" id="reportBox"></div>
      <div class="btnRow">
        <button id="btnRunAgain"></button>
        <button class="btnGhost" id="btnGuides"></button>
      </div>
    </div>

    <div class="panel hidden" id="guidesPanel">
      <h3 id="hdrGuides">GUIDES</h3>
      <div class="mono" id="guidesBox"></div>
      <div class="btnRow">
        <button class="btnGhost" id="btnBack"></button>
      </div>
    </div>

    <div class="footerNote" id="footerNote">
      NOTE: This Mini App can clear only data created inside this Mini App (cache/temp stored locally) and provides storage/network guidance.
    </div>

  </div>

  <script>
    const tg = window.Telegram?.WebApp;
    if (tg) {
      tg.ready();
      try { tg.expand(); } catch (_) {}
    }

    const I18N = {
      ru: {
        LANG: "ЯЗЫК",
        READY: "ГОТОВО",
        LOADING_AD: "ЗАГРУЗКА РЕКЛАМЫ…",
        RUNNING: "ВЫПОЛНЕНИЕ…",
        REPORT_READY: "ОТЧЁТ ГОТОВ",
        REPORT: "SCR REPORT",
        GUIDES: "ГАЙДЫ",
        RUN_AGAIN: "ПОВТОРИТЬ (РЕКЛАМА)",
        OPEN_GUIDES: "ОТКРЫТЬ ГАЙДЫ",
        BACK: "НАЗАД",
        NOTE: "ПРИМЕЧАНИЕ: Mini App очищает только локальные данные этого Mini App (кэш/временные данные) и показывает рекомендации по памяти/сети.",
        GUIDE_TEXT:
`• Telegram: Настройки → Данные и память → Использование памяти → Очистить кэш.
• Держи свободными 10–15% памяти.
• Wi-Fi обычно стабильнее. Если лагает — проверь задержку (latency) и перезапусти сеть.`,
        DEVICE: "УСТРОЙСТВО",
        NETWORK: "СЕТЬ",
        STORAGE: "ПАМЯТЬ",
        CLEANUP: "ОЧИСТКА",
        STATUS: "СТАТУС",
        CHECKLIST: "ЧЕК-ЛИСТ",
        BEFORE: "до",
        UNKNOWN: "н/д",
      },
      en: {
        LANG: "LANG",
        READY: "READY",
        LOADING_AD: "LOADING AD…",
        RUNNING: "RUNNING…",
        REPORT_READY: "REPORT READY",
        REPORT: "SCR REPORT",
        GUIDES: "GUIDES",
        RUN_AGAIN: "RUN AGAIN (AD)",
        OPEN_GUIDES: "OPEN GUIDES",
        BACK: "BACK",
        NOTE: "NOTE: This Mini App clears only local data created inside this Mini App (cache/temp) and provides storage/network guidance.",
        GUIDE_TEXT:
`• Telegram: Settings → Data and Storage → Storage Usage → Clear cache.
• Keep 10–15% free storage.
• Wi-Fi is usually more stable. If it lags — check latency and restart network.`,
        DEVICE: "DEVICE",
        NETWORK: "NETWORK",
        STORAGE: "STORAGE",
        CLEANUP: "CLEANUP",
        STATUS: "STATUS",
        CHECKLIST: "CHECKLIST",
        BEFORE: "before",
        UNKNOWN: "n/a",
      },
      zh: {
        LANG: "语言",
        READY: "就绪",
        LOADING_AD: "广告加载中…",
        RUNNING: "处理中…",
        REPORT_READY: "报告已生成",
        REPORT: "SCR 报告",
        GUIDES: "指南",
        RUN_AGAIN: "再次运行（广告）",
        OPEN_GUIDES: "打开指南",
        BACK: "返回",
        NOTE: "说明：本 Mini App 仅清理本应用产生的本地缓存/临时数据，并提供存储/网络建议。",
        GUIDE_TEXT:
`• Telegram：设置 → 数据与存储 → 存储使用情况 → 清理缓存。
• 建议保留 10–15% 可用空间。
• Wi-Fi 通常更稳定；卡顿时可查看延迟并重启网络。`,
        DEVICE: "设备",
        NETWORK: "网络",
        STORAGE: "存储",
        CLEANUP: "清理",
        STATUS: "状态",
        CHECKLIST: "检查清单",
        BEFORE: "之前",
        UNKNOWN: "未知",
      }
    };

    function getSavedLang() {
      const v = localStorage.getItem("scr_lang");
      return (v && I18N[v]) ? v : "ru";
    }
    let LANG = getSavedLang();
    function t(key) { return (I18N[LANG] && I18N[LANG][key]) || I18N.en[key] || key; }

    function applyI18n() {
      document.getElementById("lblLang").innerText = t("LANG");
      document.getElementById("hdrReport").innerText = t("REPORT");
      document.getElementById("hdrGuides").innerText = t("GUIDES");
      document.getElementById("btnRunAgain").innerText = t("RUN_AGAIN");
      document.getElementById("btnGuides").innerText = t("OPEN_GUIDES");
      document.getElementById("btnBack").innerText = t("BACK");
      document.getElementById("footerNote").innerText = t("NOTE");
    }

    function getOrCreateAppId() {
      const k = "scr_app_device_id";
      let v = localStorage.getItem(k);
      if (!v) {
        v = (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()) + "-" + Math.random().toString(16).slice(2));
        localStorage.setItem(k, v);
      }
      return v;
    }

    // ===== In-app cache simulation (honest: only inside this mini app) =====
    const CACHE_PREFIX = "scr_cache_";
    const META_LAST_CLEAN = "scr_last_clean_ts";
    const META_RUN_TODAY = "scr_runs_today";

    function bytesToMB(bytes) { return Math.max(0, bytes) / (1024 * 1024); }

    function approximateLocalStorageBytes() {
      let total = 0;
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        const v = localStorage.getItem(k);
        if (k && v && k.startsWith(CACHE_PREFIX)) total += (k.length + v.length) * 2;
      }
      return total;
    }

    function fillCacheToMinimum(minMB) {
      const currentMB = bytesToMB(approximateLocalStorageBytes());
      if (currentMB >= minMB) return;
      const targetMB = minMB + (Math.random() * 1.5);
      const neededBytes = Math.max(0, (targetMB - currentMB) * 1024 * 1024);
      const chunkChars = 20000; // ~40KB
      const chunk = "X".repeat(chunkChars);

      let writtenBytes = 0, idx = 0;
      while (writtenBytes < neededBytes && idx < 400) {
        try {
          const key = CACHE_PREFIX + Date.now() + "_" + idx;
          localStorage.setItem(key, chunk + idx);
          writtenBytes += (key.length + chunk.length + String(idx).length) * 2;
          idx++;
        } catch (_) { break; }
      }
    }

    function simulateTempBytes() {
      const b = Math.floor((0.2 + Math.random() * 1.2) * 1024 * 1024);
      localStorage.setItem("scr_temp_bytes", String(b));
      return b;
    }

    function clearCacheAndTemp() {
      let clearedBytes = 0;
      const keys = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i);
        if (k && k.startsWith(CACHE_PREFIX)) keys.push(k);
      }
      for (const k of keys) {
        const v = localStorage.getItem(k) || "";
        clearedBytes += (k.length + v.length) * 2;
        localStorage.removeItem(k);
      }
      const tempBytes = Number(localStorage.getItem("scr_temp_bytes") || "0");
      localStorage.setItem("scr_temp_bytes", "0");
      localStorage.setItem(META_LAST_CLEAN, String(Date.now()));
      return { clearedBytes, tempBytes };
    }

    function daysSinceLastClean() {
      const ts = Number(localStorage.getItem(META_LAST_CLEAN) || "0");
      if (!ts) return null;
      return Math.floor((Date.now() - ts) / (1000 * 60 * 60 * 24));
    }

    function incRunsToday() {
      const d = new Date();
      const day = `${d.getFullYear()}-${d.getMonth()+1}-${d.getDate()}`;
      let obj = { day, n: 0 };
      try { const s = localStorage.getItem(META_RUN_TODAY); if (s) obj = JSON.parse(s); } catch (_) {}
      if (obj.day !== day) obj = { day, n: 0 };
      obj.n += 1;
      localStorage.setItem(META_RUN_TODAY, JSON.stringify(obj));
      return obj.n;
    }

    // ===== Network diagnostics (safe) =====
    async function fetchPublicIP() {
      // external service; returns only IP
      try {
        const r = await fetch("https://api.ipify.org?format=json", { cache: "no-store" });
        const j = await r.json();
        return j?.ip || null;
      } catch (_) { return null; }
    }

    function getConnectionInfo() {
      const c = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
      if (!c) return { effectiveType: null, downlink: null, rtt: null, saveData: null };
      return {
        effectiveType: c.effectiveType || null,
        downlink: (typeof c.downlink === "number") ? c.downlink : null,
        rtt: (typeof c.rtt === "number") ? c.rtt : null,
        saveData: (typeof c.saveData === "boolean") ? c.saveData : null
      };
    }

    async function measureLatencyMs(trials = 3) {
      const times = [];
      for (let i = 0; i < trials; i++) {
        const url = `${location.origin}/ping.txt?cb=${Date.now()}_${i}`;
        const t0 = performance.now();
        try {
          await fetch(url, { cache: "no-store" });
          const t1 = performance.now();
          times.push(t1 - t0);
        } catch (_) {
          // If ping.txt not found, return null
          return null;
        }
      }
      const avg = times.reduce((a,b)=>a+b,0) / times.length;
      return Math.round(avg);
    }

    // ===== Score + issues =====
    function computeScoreAndIssues({ appCacheMB, daysNoClean, runsToday, latencyMs, ipAvailable }) {
      const issues = [];

      if (appCacheMB >= 0.4) issues.push("APP_CACHE_HIGH");
      if (appCacheMB >= 0.8) issues.push("APP_CACHE_CRITICAL");

      if (daysNoClean === null) issues.push("NO_CLEAN_HISTORY");
      else {
        if (daysNoClean >= 7) issues.push("NO_CLEAN_7D");
        if (daysNoClean >= 14) issues.push("NO_CLEAN_14D");
      }

      if (runsToday >= 3) issues.push("FREQUENT_RUNS");

      if (latencyMs !== null) {
        if (latencyMs >= 350) issues.push("LATENCY_HIGH");
        if (latencyMs >= 800) issues.push("LATENCY_CRITICAL");
      } else {
        issues.push("LATENCY_UNKNOWN");
      }

      if (!ipAvailable) issues.push("IP_UNKNOWN");

      // Penalties
      let Pcache = 0;
      if (appCacheMB < 0.15) Pcache = 0;
      else if (appCacheMB < 0.40) Pcache = 10;
      else if (appCacheMB < 0.80) Pcache = 18;
      else Pcache = 25;

      let Pdays = 0;
      if (daysNoClean === null) Pdays = 6;
      else if (daysNoClean < 2) Pdays = 0;
      else if (daysNoClean < 7) Pdays = 5;
      else if (daysNoClean < 14) Pdays = 10;
      else Pdays = 15;

      let Plat = 0;
      if (latencyMs === null) Plat = 6;
      else if (latencyMs < 120) Plat = 0;
      else if (latencyMs < 350) Plat = 5;
      else if (latencyMs < 800) Plat = 10;
      else Plat = 15;

      let Pissues = 0;
      const n = issues.length;
      if (n <= 1) Pissues = 0;
      else if (n <= 3) Pissues = 4;
      else if (n <= 5) Pissues = 7;
      else Pissues = 10;

      const score = Math.max(0, Math.min(100, Math.round(100 - Pcache - Pdays - Plat - Pissues)));
      return { score, issues };
    }

    function renderDeviceBox() {
      const appId = getOrCreateAppId();
      const platform = tg?.platform || "unknown";
      const version = tg?.version || "unknown";
      const scheme = tg?.colorScheme || "dark";
      const initUnsafe = tg?.initDataUnsafe;
      const user = initUnsafe?.user;

      document.getElementById("pillEnv").innerText = `ENV: TMA/${platform}`;
      document.getElementById("pillNet").innerText = `NET: LOCKED`;

      const lines = [
        `${t("DEVICE")}`,
        `platform: ${platform}`,
        `tg_version: ${version}`,
        `theme: ${scheme}`,
        `app_device_id: ${appId}`,
        `tg_user: ${user ? (user.id + (user.username ? " / @" + user.username : "")) : t("UNKNOWN")}`,
        `net_check: locked (tap RUN)`,
        `ua: ${navigator.userAgent}`
      ];
      document.getElementById("deviceBox").innerText = lines.join("\n");
    }

    function renderReport(data) {
      const unknown = t("UNKNOWN");
      const beforeWord = t("BEFORE");

      const checklist = [
        `• Clear Telegram cache (guide)`,
        `• Remove large videos (guide)`,
        `• Keep 10–15% storage free`,
        `• If latency high — switch network / reboot router`
      ];

      const connLine = (() => {
        const c = data.conn;
        if (!c) return `connection: ${unknown}`;
        const parts = [];
        if (c.effectiveType) parts.push(`type=${c.effectiveType}`);
        if (typeof c.downlink === "number") parts.push(`down=${c.downlink}Mbps`);
        if (typeof c.rtt === "number") parts.push(`rtt=${c.rtt}ms`);
        if (typeof c.saveData === "boolean") parts.push(`saveData=${c.saveData}`);
        return `connection: ${parts.length ? parts.join(" ") : unknown}`;
      })();

      const reportLines = [
        `${t("DEVICE")}`,
        `platform: ${data.platform}`,
        ``,
        `${t("NETWORK")}`,
        `online: ${navigator.onLine}`,
        `public_ip: ${data.publicIP || unknown}`,
        `latency_avg_ms: ${data.latencyMs !== null ? data.latencyMs : unknown}`,
        connLine,
        ``,
        `${t("STORAGE")}`,
        `free_storage: ${unknown}`,
        `app_cache: ${data.cacheBeforeMB.toFixed(2)} MB (${beforeWord})`,
        `days_since_clean: ${data.daysNoClean === null ? unknown : data.daysNoClean}`,
        `runs_today: ${data.runsToday}`,
        ``,
        `${t("CLEANUP")}`,
        `cache_cleared: ${data.cacheClearedMB.toFixed(2)} MB`,
        `temp_removed: ${data.tempRemovedMB.toFixed(2)} MB`,
        `storage_freed: ${data.storageFreedMB.toFixed(2)} MB`,
        ``,
        `${t("STATUS")}`,
        `scr_score: ${data.score}/100`,
        `issues_found: ${data.issues.length}`,
        `issues: ${data.issues.length ? data.issues.join(", ") : "OK"}`,
        ``,
        `${t("CHECKLIST")}`,
        ...checklist
      ];

      document.getElementById("reportBox").innerText = reportLines.join("\n");
      document.getElementById("reportPanel").classList.remove("hidden");
      document.getElementById("guidesPanel").classList.add("hidden");
      document.getElementById("pillNet").innerText = `NET: OK`;
    }

    function renderGuides() {
      document.getElementById("guidesBox").innerText = t("GUIDE_TEXT");
      document.getElementById("guidesPanel").classList.remove("hidden");
      document.getElementById("reportPanel").classList.add("hidden");
    }

    // Rewarded placeholder (mock)
    async function showRewardedAdMock() {
      await new Promise(r => setTimeout(r, 900));
      await new Promise(r => setTimeout(r, 1100));
      return true;
    }

    let busy = false;
    const toggleBtn = document.getElementById("toggleBtn");
    const statusText = document.getElementById("statusText");
    function setStatus(key) { statusText.innerText = t(key); }

    async function runOnce() {
      if (busy) return;
      busy = true;

      toggleBtn.innerText = "ON";
      setStatus("LOADING_AD");

      fillCacheToMinimum(1.2);
      const runsToday = incRunsToday();
      simulateTempBytes();

      const rewarded = await showRewardedAdMock();
      if (!rewarded) {
        toggleBtn.innerText = "OFF";
        setStatus("READY");
        busy = false;
        return;
      }

      setStatus("RUNNING");

      const platform = tg?.platform || "unknown";
      const cacheBeforeBytes = approximateLocalStorageBytes();
      const cacheBeforeMB = bytesToMB(cacheBeforeBytes);

      // Network checks (after "ad" to feel like unlocked)
      const [publicIP, latencyMs] = await Promise.all([
        fetchPublicIP(),
        measureLatencyMs(3)
      ]);
      const conn = getConnectionInfo();

      const { clearedBytes, tempBytes } = clearCacheAndTemp();
      const cacheClearedMB = bytesToMB(clearedBytes);
      const tempRemovedMB = bytesToMB(tempBytes);
      const storageFreedMB = cacheClearedMB + tempRemovedMB;

      const daysNoClean = daysSinceLastClean();

      const { score, issues } = computeScoreAndIssues({
        appCacheMB: cacheBeforeMB,
        daysNoClean,
        runsToday,
        latencyMs,
        ipAvailable: !!publicIP
      });

      renderReport({
        platform,
        runsToday,
        cacheBeforeMB,
        cacheClearedMB,
        tempRemovedMB,
        storageFreedMB,
        daysNoClean,
        publicIP,
        latencyMs,
        conn,
        score,
        issues
      });

      toggleBtn.innerText = "OFF";
      setStatus("REPORT_READY");
      busy = false;
    }

    // wiring
    document.getElementById("lang").addEventListener("change", (e) => {
      const v = e.target.value;
      if (!I18N[v]) return;
      LANG = v;
      localStorage.setItem("scr_lang", LANG);
      applyI18n();
      renderDeviceBox();
      setStatus("READY");
    });

    toggleBtn.addEventListener("click", () => {
      runOnce().catch(() => {
        toggleBtn.innerText = "OFF";
        setStatus("READY");
        busy = false;
      });
    });

    document.getElementById("btnRunAgain").addEventListener("click", () => {
      runOnce().catch(() => {});
    });

    document.getElementById("btnGuides").addEventListener("click", () => renderGuides());
    document.getElementById("btnBack").addEventListener("click", () => {
      document.getElementById("guidesPanel").classList.add("hidden");
      document.getElementById("reportPanel").classList.remove("hidden");
    });

    // init
    document.getElementById("lang").value = LANG;
    applyI18n();
    renderDeviceBox();
    setStatus("READY");
  </script>
</body>
</html>
